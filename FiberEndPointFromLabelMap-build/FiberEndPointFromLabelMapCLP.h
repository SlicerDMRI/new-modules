// This file was automatically generated by:
//  /home/brain/Slicer/Slicer-SuperBuild/SlicerExecutionModel-build/GenerateCLP/bin/GenerateCLP --InputXML /home/brain/Sandbox/FiberEndPointFromLabelMap/FiberEndPointFromLabelMap.xml --OutputCxx /home/brain/Sandbox/FiberEndPointFromLabelMap-build/FiberEndPointFromLabelMapCLP.h
//
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <map>

#include <sstream>
#include <fstream>
#include <stdexcept>

#include "tclap/CmdLine.h"
#include "JsonSerializationUtilities.h"
#include "ModuleProcessInformation.h"

#ifdef _WIN32
#define Module_EXPORT __declspec(dllexport)
#elif defined(MODULE_HIDDEN_VISIBILITY)
#define Module_EXPORT __attribute__((visibility("default")))
#else
#define Module_EXPORT
#endif


extern "C" {
Module_EXPORT char JSONModuleDescription[] =
"{\n"
"	\"Category\" : \"Diffusion.Tractography\",\n"
"	\"Contributor\" : \"Fan Zhang, Lauren O'Donnell\",\n"
"	\"Description\" : \"Fiber Endpoint From Label Map allows a user to calculate the perentage of fibers whose endpoints touching certain regions in a label map. The labelmap is provided by users, which can be generated from, e.g., Freesurfer.\",\n"
"	\"DocumentationURL\" : \"\",\n"
"	\"License\" : \"\",\n"
"	\"ParameterGroups\" : \n"
"	[\n"
"		{\n"
"			\"Description\" : \"Input/output parameters\",\n"
"			\"Label\" : \"IO\",\n"
"			\"Parameters\" : \n"
"			[\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Label map volume\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"0\",\n"
"					\"Label\" : \"Input Label Map\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"InputLabel_A\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"image\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Directory from which to read fibers\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"1\",\n"
"					\"Label\" : \"Fibers File Folder\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"InputDirectory\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"directory\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"output\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Output measurement file\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"2\",\n"
"					\"Label\" : \"Output Text File\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"outputFile\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"file\"\n"
"				}\n"
"			]\n"
"		}\n"
"	],\n"
"	\"Title\" : \"Fiber Endpoint From Label Map\",\n"
"	\"Version\" : \"1.0.0\"\n"
"}\n"
"\n"
;
}
#define GENERATE_DESERIALIZATION \
    if (argc >= 2) \
      { \
      for (int i = 0; i < argc; ++i) \
        { \
        if (strcmp(argv[i],"--deserialize") == 0) \
          { \
          std::ifstream fStream( argv[i+1] ); \
          if( !fStream.is_open() ) \
            { \
            std::cerr << "Could not open file: " << argv[i+1] << " for writing." << std::endl; \
            return EXIT_FAILURE; \
            } \
          Json::Value root; \
          Json::Reader reader; \
          reader.parse( fStream, root ); \
          const Json::Value & parameters = root["Parameters"]; \
          if (!parameters["IO"]["InputLabel_A"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["InputLabel_A"].asString()); \
            } \
          if (!parameters["IO"]["InputDirectory"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["InputDirectory"].asString()); \
            } \
          if (!parameters["IO"]["outputFile"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["outputFile"].asString()); \
            } \
          } \
        } \
      }
#define GENERATE_SERIALIZATION \
    if( parametersSerializeArg.isSet() ) \
      { \
      Json::Value root; \
      Json::Value & parameters = root["Parameters"]; \
        { \
        Json::Value & parameterGroup = parameters["IO"]; \
        parameterGroup["InputLabel_A"] = JsonSerialize( InputLabel_A ); \
        parameterGroup["InputDirectory"] = JsonSerialize( InputDirectory ); \
        parameterGroup["outputFile"] = JsonSerialize( outputFile ); \
        } \
      std::ofstream fStream( parametersSerializeArg.getValue().c_str() ); \
      if( !fStream.is_open() ) \
        { \
        std::cerr << "Could not open file: " << parametersSerializeArg.getValue() << " for writing." << std::endl; \
        return EXIT_FAILURE; \
        } \
      Json::StyledStreamWriter writer; \
      writer.write( fStream, root ); \
      fStream.close(); \
      }
#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>\n"
"  Diffusion.Tractography\n"
"  </category>\n"
"  <title>\n"
"  Fiber Endpoint From Label Map\n"
"  </title>\n"
"  <description>\n"
"Fiber Endpoint From Label Map allows a user to calculate the perentage of fibers whose endpoints touching certain regions in a label map. The labelmap is provided by users, which can be generated from, e.g., Freesurfer. \n"
"  </description>\n"
"  <version>1.0.0</version>\n"
"  <documentation-url></documentation-url>\n"
"  <license></license>\n"
"  <contributor>Fan Zhang, Lauren O'Donnell</contributor>\n"
"  <acknowledgements>BWH, NCIGT/NAC/LMI/SPL, USYD</acknowledgements>\n"
"\n"
"  <parameters>\n"
"    <label>IO</label>\n"
"    <description>Input/output parameters</description>\n"
"    <image type =\"label\">\n"
"      <name>InputLabel_A</name>\n"
"      <label>Input Label Map</label>\n"
"      <channel>input</channel>\n"
"      <index>0</index>\n"
"      <description>Label map volume</description>\n"
"    </image>\n"
"    <directory>\n"
"      <name>InputDirectory</name>\n"
"      <label>Fibers File Folder</label>\n"
"      <channel>input</channel>\n"
"      <index>1</index>\n"
"      <description>Directory from which to read fibers</description>\n"
"    </directory>\n"
"    <file>\n"
"      <name>outputFile</name>\n"
"      <label>Output Text File</label>\n"
"      <channel>output</channel>\n"
"      <index>2</index>\n"
"      <description>Output measurement file</description>\n"
"    </file>\n"
"  </parameters>\n"
"\n"
"</executable>\n"
"\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_DECLARE \
    /* These two vectors are used to store the JSON deserialized value */ \
    /* that are then compiled with the command line. */ \
    std::vector< std::string > deserializedVectorFlaggedArgs; \
    std::vector< std::string > deserializedVectorPositionalArgs; \
    /* This map is used to store the JSON deserialized value of multiple args*/ \
    /* where the key is the argument flag and the value the values of each arg. */ \
    std::map< std::string, std::vector<std::string> > deserializedMultipleArgsMap; \
 \
    /* This vector is used to look up if a flag requires an argument after it. */ \
    /* This is used to differentiate between: */ \
    /* ./myExec --boolFlag /my/first/arg */ \
    /* ./myExec --flag flagArg */ \
    std::vector< std::string > nonbooleanFlags; \
    nonbooleanFlags.push_back("--serialize"); \
    nonbooleanFlags.push_back("--deserialize"); \
    nonbooleanFlags.push_back("--processinformationaddress"); \
    nonbooleanFlags.push_back("--returnparameterfile"); \
    /* This map use is twofold: */ \
    /*  - to find whether a flag is multiple */ \
    /*  - to know if we need to reset the multiple arg value because it was */ \
    /*    in the JSON and it's also in the command line. */ \
    std::map<std::string, bool> multipleFlags; \
    std::string InputLabel_A; \
    std::string InputDirectory; \
    std::string outputFile; \
    std::string parametersSerialize; \
    std::string parametersDeSerialize; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \

#define GENERATE_TCLAP_PARSE \
    std::string fullDescription("Description: "); \
    fullDescription += "Fiber Endpoint From Label Map allows a user to calculate the perentage of fibers whose endpoints touching certain regions in a label map. The labelmap is provided by users, which can be generated from, e.g., Freesurfer."; \
    if (!std::string("Fan Zhang, Lauren O'Donnell").empty()) \
      { \
      fullDescription += "\nAuthor(s): Fan Zhang, Lauren O'Donnell"; \
      } \
    if (!std::string("BWH, NCIGT/NAC/LMI/SPL, USYD").empty()) \
      { \
      fullDescription += "\nAcknowledgements: BWH, NCIGT/NAC/LMI/SPL, USYD"; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "1.0.0" ); \
 \
      std::ostringstream msg; \
    msg.str("");msg << "Label map volume";    TCLAP::UnlabeledValueArg<std::string> InputLabel_AArg("InputLabel_A", msg.str(), 1, InputLabel_A, "std::string", commandLine); \
 \
    msg.str("");msg << "Directory from which to read fibers";    TCLAP::UnlabeledValueArg<std::string> InputDirectoryArg("InputDirectory", msg.str(), 1, InputDirectory, "std::string", commandLine); \
 \
    msg.str("");msg << "Output measurement file";    TCLAP::UnlabeledValueArg<std::string> outputFileArg("outputFile", msg.str(), 1, outputFile, "std::string", commandLine); \
 \
    msg.str("");msg << "Store the module's parameters to a file.";    TCLAP::ValueArg<std::string > parametersSerializeArg("", "serialize", msg.str(), 0, parametersSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Restore the module's parameters that were previously archived.";    TCLAP::ValueArg<std::string > parametersDeSerializeArg("", "deserialize", msg.str(), 0, parametersDeSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
 \
    /* Go through argc and consolidate the JSON with the parameters from the command line */ \
    /* In case of conflict, take the command line. */ \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    std::vector<std::string>::iterator dvOptionnalArgsIt = deserializedVectorFlaggedArgs.begin(); \
    std::map<std::string, std::vector<std::string> >::iterator dvMultipleArgsIt; \
    size_t noFlagCounter = 0; \
    size_t ac = 1; \
 \
    while (ac < static_cast<size_t>(argc)) \
      { \
      /* short flag case && long flag case */ \
       if ((strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
           || (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-')) \
         { \
         std::string flag = argv[ac]; \
         /* Remap the flag if necessary */ \
         if (strlen(argv[ac]) == 2) \
           { \
           /* Short flag remapping */ \
           ait = flagAliasMap.find(flag); \
           dait = deprecatedFlagAliasMap.find(flag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << flag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         else \
           { \
           /* Long flag remapping */ \
           ait = longFlagAliasMap.find(flag); \
           dait = deprecatedLongFlagAliasMap.find(flag); \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << flag << "\" is deprecated. Please use long flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         bool isMultiple = multipleFlags.find(flag) != multipleFlags.end(); \
         bool isBoolean = std::find(nonbooleanFlags.begin(), nonbooleanFlags.end(), flag) == nonbooleanFlags.end(); \
         dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), flag); \
         bool isPresentVFA = dvOptionnalArgsIt != deserializedVectorFlaggedArgs.end(); \
         if (isBoolean) \
           { \
           /*Ignore if boolean and already present*/ \
           /*Otherwise add it*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           } \
         else if (isMultiple) \
           { \
           dvMultipleArgsIt = deserializedMultipleArgsMap.find(flag); \
           bool isPresentMA = dvMultipleArgsIt != deserializedMultipleArgsMap.end(); \
           /*Ignore if boolean and already present*/ \
           /*Reset/Add the value if first deserialize or not present*/ \
           if (!isPresentMA || !multipleFlags[flag]) \
             { \
             deserializedMultipleArgsMap[flag] = std::vector<std::string>(); \
             multipleFlags[flag] = true; \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           deserializedMultipleArgsMap[flag].push_back(value); \
           } \
         else \
           { \
           /*Add the flag and if needed*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(value);  \
             } \
           else \
             { \
             *(++dvOptionnalArgsIt) = value; \
             } \
           } \
         } \
       /* short flag case where multiple flags are given at once */ \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         std::string rflag(argv[ac], 1, std::string::npos); \
         for (std::string::size_type fi=0; fi < rflag.size(); ++fi) \
           { \
           std::string tf(rflag, fi, 1); \
           std::string newFlag ="-"; \
           newFlag += tf; \
           ait = flagAliasMap.find(newFlag); \
           dait = deprecatedFlagAliasMap.find(newFlag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             newFlag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << newFlag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             newFlag = (*dait).second; \
             } \
           dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), newFlag); \
           /*These flags are always boolean, just add it if it's not there already */ \
           if (dvOptionnalArgsIt == deserializedVectorFlaggedArgs.end()) \
             { \
             deserializedVectorFlaggedArgs.push_back(newFlag); \
             } \
           } \
         ++ac; \
         } \
       else \
         { \
         /* Replace if needed, otherwise append.*/ \
         if (noFlagCounter < deserializedVectorPositionalArgs.size()) \
           { \
           deserializedVectorPositionalArgs[noFlagCounter] = argv[ac]; \
           } \
         else \
           { \
           deserializedVectorPositionalArgs.push_back(argv[ac]); \
           } \
         ++ac; \
         ++noFlagCounter; \
         } \
       } \
 \
    /* Put the now compiled arguments in the argvVector */ \
    std::vector<std::string> argvVector; \
    argvVector.push_back(argv[0]); \
    argvVector.insert(argvVector.end(), deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end()); \
    std::map<std::string, std::vector<std::string> >::iterator mavit; \
    for (mavit = deserializedMultipleArgsMap.begin(); mavit != deserializedMultipleArgsMap.end(); ++mavit) \
      { \
      for (size_t i = 0; i < mavit->second.size(); ++i) \
        { \
        argvVector.push_back(mavit->first); \
        argvVector.push_back(mavit->second.at(i)); \
        } \
      } \
    argvVector.insert(argvVector.end(), deserializedVectorPositionalArgs.begin(), deserializedVectorPositionalArgs.end()); \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < argvVector.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(argvVector[ac].c_str())); \
     } \
    commandLine.parse ( static_cast<int>(vargs.size()), (char**) &(vargs[0]) ); \
  } \
catch ( TCLAP::ArgException & e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_TCLAP_ASSIGNMENT \
      InputLabel_A = InputLabel_AArg.getValue(); \
      InputDirectory = InputDirectoryArg.getValue(); \
      outputFile = outputFileArg.getValue(); \
      parametersSerialize = parametersSerializeArg.getValue(); \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      echoSwitch = echoSwitchArg.getValue(); \
      xmlSwitch = xmlSwitchArg.getValue(); \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      returnParameterFile = returnParameterFileArg.getValue(); \

#define GENERATE_TCLAP GENERATE_TCLAP_PARSE;GENERATE_TCLAP_ASSIGNMENT
#define GENERATE_TCLAP_ASSIGNMENT_IFSET \
    if( InputLabel_AArg.isSet() ) \
      { \
      InputLabel_A = InputLabel_AArg.getValue(); \
      } \
    if( InputDirectoryArg.isSet() ) \
      { \
      InputDirectory = InputDirectoryArg.getValue(); \
      } \
    if( outputFileArg.isSet() ) \
      { \
      outputFile = outputFileArg.getValue(); \
      } \
    if( parametersSerializeArg.isSet() ) \
      { \
      parametersSerialize = parametersSerializeArg.getValue(); \
      } \
    if( parametersDeSerializeArg.isSet() ) \
      { \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      } \
    if( echoSwitchArg.isSet() ) \
      { \
      echoSwitch = echoSwitchArg.getValue(); \
      } \
    if( xmlSwitchArg.isSet() ) \
      { \
      xmlSwitch = xmlSwitchArg.getValue(); \
      } \
    if( processInformationAddressStringArg.isSet() ) \
      { \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      } \
    if( returnParameterFileArg.isSet() ) \
      { \
      returnParameterFile = returnParameterFileArg.getValue(); \
      } \

#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    InputLabel_A: " << InputLabel_A << std::endl; \
std::cout << "    InputDirectory: " << InputDirectory << std::endl; \
std::cout << "    outputFile: " << outputFile << std::endl; \
std::cout << "    parametersSerialize: " << parametersSerialize << std::endl; \
std::cout << "    parametersDeSerialize: " << parametersDeSerialize << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_DECLARE;GENERATE_DESERIALIZATION;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;GENERATE_SERIALIZATION;
