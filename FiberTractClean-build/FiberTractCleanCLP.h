// This file was automatically generated by:
//  /home/brain/Slicer/Slicer-SuperBuild/SlicerExecutionModel-build/GenerateCLP/bin/GenerateCLP --InputXML /home/brain/Sandbox/FiberTractClean/FiberTractClean.xml --OutputCxx /home/brain/Sandbox/FiberTractClean-build/FiberTractCleanCLP.h
//
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <map>

#include <sstream>
#include <fstream>
#include <stdexcept>

#include "tclap/CmdLine.h"
#include "JsonSerializationUtilities.h"
#include "ModuleProcessInformation.h"

#ifdef _WIN32
#define Module_EXPORT __declspec(dllexport)
#elif defined(MODULE_HIDDEN_VISIBILITY)
#define Module_EXPORT __attribute__((visibility("default")))
#else
#define Module_EXPORT
#endif


extern "C" {
Module_EXPORT char JSONModuleDescription[] =
"{\n"
"	\"Category\" : \"Diffusion.Tractography\",\n"
"	\"Contributor\" : \"Fan Zhang, Lauren O'Donnell\",\n"
"	\"Description\" : \"Using an input whole brain mask, remove spurious fibers that are very parallel to the surface of the mask (e.g. in skull or CSF). Also remove very short fibers (by default those with fewer than 2 points, which are just an artifact of unsuccessful seeding).\",\n"
"	\"DocumentationURL\" : \"http://wiki.slicer.org/slicerWiki/index.php/Documentation/4.4/Modules/FiberTractClean\",\n"
"	\"License\" : \"\",\n"
"	\"ParameterGroups\" : \n"
"	[\n"
"		{\n"
"			\"Description\" : \"Input/output parameters\",\n"
"			\"Label\" : \"IO\",\n"
"			\"Parameters\" : \n"
"			[\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Label map (brain mask) volume\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"0\",\n"
"					\"Label\" : \"Input Brain Mask\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"InputLabel_A\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"image\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"input\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Input tractography\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"1\",\n"
"					\"Label\" : \"Input Fiber Bundle\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"InputFibers\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"geometry\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"output\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Cleaned tractography result\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"2\",\n"
"					\"Label\" : \"Output Kept Fiber Bundle\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"OutputKeptFibers\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"geometry\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"std::string\",\n"
"					\"Channel\" : \"output\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"\",\n"
"					\"Description\" : \"Removed fibers\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"\",\n"
"					\"Index\" : \"3\",\n"
"					\"Label\" : \"Output Removed Fiber Bundle\",\n"
"					\"LongFlag\" : \"\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"OutputRemovedFibers\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"geometry\"\n"
"				}\n"
"			]\n"
"		},\n"
"		{\n"
"			\"Description\" : \"Advanced parameters\",\n"
"			\"Label\" : \"Advanced\",\n"
"			\"Parameters\" : \n"
"			[\n"
"				{\n"
"					\"CPPType\" : \"int\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"2\",\n"
"					\"Description\" : \"The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"p\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Minimum fiber length (in points)\",\n"
"					\"LongFlag\" : \"points\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"MinimumNumberOfPoints\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"integer\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"int\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"4\",\n"
"					\"Description\" : \"How much to erode (shrink) the brain mask by to assess what tracts are mostly outside the mask.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"k\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Size of brain mask erosion kernel in voxels\",\n"
"					\"LongFlag\" : \"kernelsize\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"KernelSize\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"integer\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"float\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"0.9\",\n"
"					\"Description\" : \"A number between 0 and 1. This percentage of the fiber must be inside the eroded mask to keep the fiber. This removes fibers in the skull/CSF.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"f\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Fraction of fiber in mask to keep tract\",\n"
"					\"LongFlag\" : \"frac\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"PercentInsideMask\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"float\"\n"
"				},\n"
"				{\n"
"					\"CPPType\" : \"bool\",\n"
"					\"Channel\" : \"\",\n"
"					\"CoordinateSystem\" : \"\",\n"
"					\"Default\" : \"false\",\n"
"					\"Description\" : \"The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2.\",\n"
"					\"Elements\" : [],\n"
"					\"Flag\" : \"v\",\n"
"					\"Index\" : \"\",\n"
"					\"Label\" : \"Verbose output\",\n"
"					\"LongFlag\" : \"verbose\",\n"
"					\"Maximum\" : \"\",\n"
"					\"Minimum\" : \"\",\n"
"					\"Multiple\" : \"false\",\n"
"					\"Name\" : \"Verbose\",\n"
"					\"Step\" : \"\",\n"
"					\"Tag\" : \"boolean\"\n"
"				}\n"
"			]\n"
"		}\n"
"	],\n"
"	\"Title\" : \"Fiber Tract Clean\",\n"
"	\"Version\" : \"0.1.0.$Revision: 1892 $(alpha)\"\n"
"}\n"
"\n"
;
}
#define GENERATE_DESERIALIZATION \
    if (argc >= 2) \
      { \
      for (int i = 0; i < argc; ++i) \
        { \
        if (strcmp(argv[i],"--deserialize") == 0) \
          { \
          std::ifstream fStream( argv[i+1] ); \
          if( !fStream.is_open() ) \
            { \
            std::cerr << "Could not open file: " << argv[i+1] << " for writing." << std::endl; \
            return EXIT_FAILURE; \
            } \
          Json::Value root; \
          Json::Reader reader; \
          reader.parse( fStream, root ); \
          const Json::Value & parameters = root["Parameters"]; \
          if (!parameters["IO"]["InputLabel_A"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["InputLabel_A"].asString()); \
            } \
          if (!parameters["IO"]["InputFibers"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["InputFibers"].asString()); \
            } \
          if (!parameters["IO"]["OutputKeptFibers"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["OutputKeptFibers"].asString()); \
            } \
          if (!parameters["IO"]["OutputRemovedFibers"].isNull()) \
            { \
            deserializedVectorPositionalArgs.push_back(parameters["IO"]["OutputRemovedFibers"].asString()); \
            } \
          if (!parameters["Advanced"]["MinimumNumberOfPoints"].isNull()) \
            { \
            Json::Value param = parameters["Advanced"]["MinimumNumberOfPoints"]; \
            if (!param.isArray()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--points"); \
              deserializedVectorFlaggedArgs.push_back(param.asString()); \
              } \
            else if(param.size() > 0) \
              { \
              std::string value = ""; \
              for (unsigned int i = 0; i < param.size(); ++i) \
                { \
                value += param[i].asString(); \
                if (i < param.size() - 1) \
                  { \
                  value += ", "; \
                  } \
                } \
              deserializedVectorFlaggedArgs.push_back("--points"); \
              deserializedVectorFlaggedArgs.push_back(value); \
              } \
            } \
          if (!parameters["Advanced"]["KernelSize"].isNull()) \
            { \
            Json::Value param = parameters["Advanced"]["KernelSize"]; \
            if (!param.isArray()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--kernelsize"); \
              deserializedVectorFlaggedArgs.push_back(param.asString()); \
              } \
            else if(param.size() > 0) \
              { \
              std::string value = ""; \
              for (unsigned int i = 0; i < param.size(); ++i) \
                { \
                value += param[i].asString(); \
                if (i < param.size() - 1) \
                  { \
                  value += ", "; \
                  } \
                } \
              deserializedVectorFlaggedArgs.push_back("--kernelsize"); \
              deserializedVectorFlaggedArgs.push_back(value); \
              } \
            } \
          if (!parameters["Advanced"]["PercentInsideMask"].isNull()) \
            { \
            Json::Value param = parameters["Advanced"]["PercentInsideMask"]; \
            if (!param.isArray()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--frac"); \
              deserializedVectorFlaggedArgs.push_back(param.asString()); \
              } \
            else if(param.size() > 0) \
              { \
              std::string value = ""; \
              for (unsigned int i = 0; i < param.size(); ++i) \
                { \
                value += param[i].asString(); \
                if (i < param.size() - 1) \
                  { \
                  value += ", "; \
                  } \
                } \
              deserializedVectorFlaggedArgs.push_back("--frac"); \
              deserializedVectorFlaggedArgs.push_back(value); \
              } \
            } \
          if (!parameters["Advanced"]["Verbose"].isNull()) \
            { \
            if (parameters["Advanced"]["Verbose"].asBool()) \
              { \
              deserializedVectorFlaggedArgs.push_back("--verbose"); \
              } \
            } \
          } \
        } \
      }
#define GENERATE_SERIALIZATION \
    if( parametersSerializeArg.isSet() ) \
      { \
      Json::Value root; \
      Json::Value & parameters = root["Parameters"]; \
        { \
        Json::Value & parameterGroup = parameters["IO"]; \
        parameterGroup["InputLabel_A"] = JsonSerialize( InputLabel_A ); \
        parameterGroup["InputFibers"] = JsonSerialize( InputFibers ); \
        parameterGroup["OutputKeptFibers"] = JsonSerialize( OutputKeptFibers ); \
        parameterGroup["OutputRemovedFibers"] = JsonSerialize( OutputRemovedFibers ); \
        } \
        { \
        Json::Value & parameterGroup = parameters["Advanced"]; \
        parameterGroup["MinimumNumberOfPoints"] = JsonSerialize( MinimumNumberOfPoints ); \
        parameterGroup["KernelSize"] = JsonSerialize( KernelSize ); \
        parameterGroup["PercentInsideMask"] = JsonSerialize( PercentInsideMask ); \
        parameterGroup["Verbose"] = JsonSerialize( Verbose ); \
        } \
      std::ofstream fStream( parametersSerializeArg.getValue().c_str() ); \
      if( !fStream.is_open() ) \
        { \
        std::cerr << "Could not open file: " << parametersSerializeArg.getValue() << " for writing." << std::endl; \
        return EXIT_FAILURE; \
        } \
      Json::StyledStreamWriter writer; \
      writer.write( fStream, root ); \
      fStream.close(); \
      }
#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>\n"
"  Diffusion.Tractography\n"
"  </category>\n"
"  <title>\n"
"  Fiber Tract Clean\n"
"  </title>\n"
"  <description>\n"
"Using an input whole brain mask, remove spurious fibers that are very parallel to the surface of the mask (e.g. in skull or CSF). Also remove very short fibers (by default those with fewer than 2 points, which are just an artifact of unsuccessful seeding).\n"
"  </description>\n"
"  <version>0.1.0.$Revision: 1892 $(alpha)</version>\n"
"  <documentation-url>http://wiki.slicer.org/slicerWiki/index.php/Documentation/4.4/Modules/FiberTractClean</documentation-url>\n"
"  <license></license>\n"
"  <contributor> Fan Zhang, Lauren O'Donnell </contributor>\n"
"  <acknowledgements>BWH, NCIGT/NAC/LMI/SPL, USYD</acknowledgements>\n"
"\n"
"  <parameters>\n"
"    <label>IO</label>\n"
"    <description>Input/output parameters</description>\n"
"    <image type =\"label\">\n"
"      <name>InputLabel_A</name>\n"
"      <label>Input Brain Mask</label>\n"
"      <channel>input</channel>\n"
"      <index>0</index>\n"
"      <description>Label map (brain mask) volume</description>\n"
"    </image>\n"
"    <geometry type = \"fiberbundle\">\n"
"      <name>InputFibers</name>\n"
"      <label>Input Fiber Bundle</label>\n"
"      <channel>input</channel>\n"
"      <index>1</index>\n"
"      <description>Input tractography</description>\n"
"    </geometry>\n"
"    <geometry type = \"fiberbundle\">\n"
"      <name>OutputKeptFibers</name>\n"
"      <label>Output Kept Fiber Bundle</label>\n"
"      <channel>output</channel>\n"
"      <index>2</index>\n"
"      <description>Cleaned tractography result</description>\n"
"    </geometry>\n"
"    <geometry type = \"fiberbundle\">\n"
"      <name>OutputRemovedFibers</name>\n"
"      <label>Output Removed Fiber Bundle</label>\n"
"      <channel>output</channel>\n"
"      <index>3</index>\n"
"      <description>Removed fibers</description>\n"
"    </geometry>\n"
"  </parameters>\n"
"  \n"
"  <parameters>\n"
"    <label>Advanced</label>\n"
"    <description>Advanced parameters</description>\n"
"    \n"
"    <integer>\n"
"      <name>MinimumNumberOfPoints</name>\n"
"      <label> Minimum fiber length (in points) </label>\n"
"      <default>2</default>\n"
"      <flag>-p</flag>\n"
"      <longflag>--points</longflag>\n"
"      <description><![CDATA[The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2.]]></description>\n"
"    </integer>\n"
"\n"
"    <integer>\n"
"      <name>KernelSize</name>\n"
"      <label> Size of brain mask erosion kernel in voxels </label>\n"
"      <default>4</default>\n"
"      <flag>-k</flag>\n"
"      <longflag>--kernelsize</longflag>\n"
"      <description><![CDATA[How much to erode (shrink) the brain mask by to assess what tracts are mostly outside the mask.]]></description>\n"
"    </integer>\n"
"\n"
"    <float>\n"
"      <name>PercentInsideMask</name>\n"
"      <label> Fraction of fiber in mask to keep tract </label>\n"
"      <default>0.9</default>\n"
"      <flag>-f</flag>\n"
"      <longflag>--frac</longflag>\n"
"      <description><![CDATA[A number between 0 and 1. This percentage of the fiber must be inside the eroded mask to keep the fiber. This removes fibers in the skull/CSF. ]]></description>\n"
"    </float>\n"
"\n"
"   <boolean>\n"
"      <name>Verbose</name>\n"
"      <label> Verbose output </label>\n"
"      <default>false</default>\n"
"      <flag>-v</flag>\n"
"      <longflag>--verbose</longflag>\n"
"      <description><![CDATA[The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2.]]></description>\n"
"    </boolean>\n"
"\n"
"  </parameters>  \n"
"</executable>\n"
"\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_DECLARE \
    /* These two vectors are used to store the JSON deserialized value */ \
    /* that are then compiled with the command line. */ \
    std::vector< std::string > deserializedVectorFlaggedArgs; \
    std::vector< std::string > deserializedVectorPositionalArgs; \
    /* This map is used to store the JSON deserialized value of multiple args*/ \
    /* where the key is the argument flag and the value the values of each arg. */ \
    std::map< std::string, std::vector<std::string> > deserializedMultipleArgsMap; \
 \
    /* This vector is used to look up if a flag requires an argument after it. */ \
    /* This is used to differentiate between: */ \
    /* ./myExec --boolFlag /my/first/arg */ \
    /* ./myExec --flag flagArg */ \
    std::vector< std::string > nonbooleanFlags; \
    nonbooleanFlags.push_back("-p"); \
    nonbooleanFlags.push_back("--points"); \
    nonbooleanFlags.push_back("-k"); \
    nonbooleanFlags.push_back("--kernelsize"); \
    nonbooleanFlags.push_back("-f"); \
    nonbooleanFlags.push_back("--frac"); \
    nonbooleanFlags.push_back("--serialize"); \
    nonbooleanFlags.push_back("--deserialize"); \
    nonbooleanFlags.push_back("--processinformationaddress"); \
    nonbooleanFlags.push_back("--returnparameterfile"); \
    /* This map use is twofold: */ \
    /*  - to find whether a flag is multiple */ \
    /*  - to know if we need to reset the multiple arg value because it was */ \
    /*    in the JSON and it's also in the command line. */ \
    std::map<std::string, bool> multipleFlags; \
    std::string InputLabel_A; \
    std::string InputFibers; \
    std::string OutputKeptFibers; \
    std::string OutputRemovedFibers; \
    int MinimumNumberOfPoints = 2; \
    int KernelSize = 4; \
    float PercentInsideMask = 0.9; \
    bool Verbose = false; \
    std::string parametersSerialize; \
    std::string parametersDeSerialize; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \

#define GENERATE_TCLAP_PARSE \
    std::string fullDescription("Description: "); \
    fullDescription += "Using an input whole brain mask, remove spurious fibers that are very parallel to the surface of the mask (e.g. in skull or CSF). Also remove very short fibers (by default those with fewer than 2 points, which are just an artifact of unsuccessful seeding)."; \
    if (!std::string("Fan Zhang, Lauren O'Donnell").empty()) \
      { \
      fullDescription += "\nAuthor(s): Fan Zhang, Lauren O'Donnell"; \
      } \
    if (!std::string("BWH, NCIGT/NAC/LMI/SPL, USYD").empty()) \
      { \
      fullDescription += "\nAcknowledgements: BWH, NCIGT/NAC/LMI/SPL, USYD"; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "0.1.0.$Revision: 1892 $(alpha)" ); \
 \
      std::ostringstream msg; \
    msg.str("");msg << "Label map (brain mask) volume";    TCLAP::UnlabeledValueArg<std::string> InputLabel_AArg("InputLabel_A", msg.str(), 1, InputLabel_A, "std::string", commandLine); \
 \
    msg.str("");msg << "Input tractography";    TCLAP::UnlabeledValueArg<std::string> InputFibersArg("InputFibers", msg.str(), 1, InputFibers, "std::string", commandLine); \
 \
    msg.str("");msg << "Cleaned tractography result";    TCLAP::UnlabeledValueArg<std::string> OutputKeptFibersArg("OutputKeptFibers", msg.str(), 1, OutputKeptFibers, "std::string", commandLine); \
 \
    msg.str("");msg << "Removed fibers";    TCLAP::UnlabeledValueArg<std::string> OutputRemovedFibersArg("OutputRemovedFibers", msg.str(), 1, OutputRemovedFibers, "std::string", commandLine); \
 \
    msg.str("");msg << "The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2. (default: " << MinimumNumberOfPoints << ")"; \
    TCLAP::ValueArg<int > MinimumNumberOfPointsArg("p", "points", msg.str(), 0, MinimumNumberOfPoints, "int", commandLine); \
 \
    msg.str("");msg << "How much to erode (shrink) the brain mask by to assess what tracts are mostly outside the mask. (default: " << KernelSize << ")"; \
    TCLAP::ValueArg<int > KernelSizeArg("k", "kernelsize", msg.str(), 0, KernelSize, "int", commandLine); \
 \
    msg.str("");msg << "A number between 0 and 1. This percentage of the fiber must be inside the eroded mask to keep the fiber. This removes fibers in the skull/CSF. (default: " << PercentInsideMask << ")"; \
    TCLAP::ValueArg<float > PercentInsideMaskArg("f", "frac", msg.str(), 0, PercentInsideMask, "float", commandLine); \
 \
    msg.str("");msg << "The shortest fiber that will be kept. This is used to remove spurious short fibers. For example, to remove fibers with fewer than 2 points, enter 2. (default: " << Verbose << ")"; \
    TCLAP::SwitchArg VerboseArg("v", "verbose", msg.str(), commandLine, Verbose); \
 \
    msg.str("");msg << "Store the module's parameters to a file.";    TCLAP::ValueArg<std::string > parametersSerializeArg("", "serialize", msg.str(), 0, parametersSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Restore the module's parameters that were previously archived.";    TCLAP::ValueArg<std::string > parametersDeSerializeArg("", "deserialize", msg.str(), 0, parametersDeSerialize, "std::string", commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
 \
    /* Go through argc and consolidate the JSON with the parameters from the command line */ \
    /* In case of conflict, take the command line. */ \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    std::vector<std::string>::iterator dvOptionnalArgsIt = deserializedVectorFlaggedArgs.begin(); \
    std::map<std::string, std::vector<std::string> >::iterator dvMultipleArgsIt; \
    size_t noFlagCounter = 0; \
    size_t ac = 1; \
 \
    while (ac < static_cast<size_t>(argc)) \
      { \
      /* short flag case && long flag case */ \
       if ((strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
           || (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-')) \
         { \
         std::string flag = argv[ac]; \
         /* Remap the flag if necessary */ \
         if (strlen(argv[ac]) == 2) \
           { \
           /* Short flag remapping */ \
           ait = flagAliasMap.find(flag); \
           dait = deprecatedFlagAliasMap.find(flag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << flag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         else \
           { \
           /* Long flag remapping */ \
           ait = longFlagAliasMap.find(flag); \
           dait = deprecatedLongFlagAliasMap.find(flag); \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << flag << "\" is deprecated. Please use long flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         bool isMultiple = multipleFlags.find(flag) != multipleFlags.end(); \
         bool isBoolean = std::find(nonbooleanFlags.begin(), nonbooleanFlags.end(), flag) == nonbooleanFlags.end(); \
         dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), flag); \
         bool isPresentVFA = dvOptionnalArgsIt != deserializedVectorFlaggedArgs.end(); \
         if (isBoolean) \
           { \
           /*Ignore if boolean and already present*/ \
           /*Otherwise add it*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           } \
         else if (isMultiple) \
           { \
           dvMultipleArgsIt = deserializedMultipleArgsMap.find(flag); \
           bool isPresentMA = dvMultipleArgsIt != deserializedMultipleArgsMap.end(); \
           /*Ignore if boolean and already present*/ \
           /*Reset/Add the value if first deserialize or not present*/ \
           if (!isPresentMA || !multipleFlags[flag]) \
             { \
             deserializedMultipleArgsMap[flag] = std::vector<std::string>(); \
             multipleFlags[flag] = true; \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           deserializedMultipleArgsMap[flag].push_back(value); \
           } \
         else \
           { \
           /*Add the flag and if needed*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(value);  \
             } \
           else \
             { \
             *(++dvOptionnalArgsIt) = value; \
             } \
           } \
         } \
       /* short flag case where multiple flags are given at once */ \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         std::string rflag(argv[ac], 1, std::string::npos); \
         for (std::string::size_type fi=0; fi < rflag.size(); ++fi) \
           { \
           std::string tf(rflag, fi, 1); \
           std::string newFlag ="-"; \
           newFlag += tf; \
           ait = flagAliasMap.find(newFlag); \
           dait = deprecatedFlagAliasMap.find(newFlag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             newFlag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << newFlag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             newFlag = (*dait).second; \
             } \
           dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), newFlag); \
           /*These flags are always boolean, just add it if it's not there already */ \
           if (dvOptionnalArgsIt == deserializedVectorFlaggedArgs.end()) \
             { \
             deserializedVectorFlaggedArgs.push_back(newFlag); \
             } \
           } \
         ++ac; \
         } \
       else \
         { \
         /* Replace if needed, otherwise append.*/ \
         if (noFlagCounter < deserializedVectorPositionalArgs.size()) \
           { \
           deserializedVectorPositionalArgs[noFlagCounter] = argv[ac]; \
           } \
         else \
           { \
           deserializedVectorPositionalArgs.push_back(argv[ac]); \
           } \
         ++ac; \
         ++noFlagCounter; \
         } \
       } \
 \
    /* Put the now compiled arguments in the argvVector */ \
    std::vector<std::string> argvVector; \
    argvVector.push_back(argv[0]); \
    argvVector.insert(argvVector.end(), deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end()); \
    std::map<std::string, std::vector<std::string> >::iterator mavit; \
    for (mavit = deserializedMultipleArgsMap.begin(); mavit != deserializedMultipleArgsMap.end(); ++mavit) \
      { \
      for (size_t i = 0; i < mavit->second.size(); ++i) \
        { \
        argvVector.push_back(mavit->first); \
        argvVector.push_back(mavit->second.at(i)); \
        } \
      } \
    argvVector.insert(argvVector.end(), deserializedVectorPositionalArgs.begin(), deserializedVectorPositionalArgs.end()); \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < argvVector.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(argvVector[ac].c_str())); \
     } \
    commandLine.parse ( static_cast<int>(vargs.size()), (char**) &(vargs[0]) ); \
  } \
catch ( TCLAP::ArgException & e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_TCLAP_ASSIGNMENT \
      InputLabel_A = InputLabel_AArg.getValue(); \
      InputFibers = InputFibersArg.getValue(); \
      OutputKeptFibers = OutputKeptFibersArg.getValue(); \
      OutputRemovedFibers = OutputRemovedFibersArg.getValue(); \
      MinimumNumberOfPoints = MinimumNumberOfPointsArg.getValue(); \
      KernelSize = KernelSizeArg.getValue(); \
      PercentInsideMask = PercentInsideMaskArg.getValue(); \
      Verbose = VerboseArg.getValue(); \
      parametersSerialize = parametersSerializeArg.getValue(); \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      echoSwitch = echoSwitchArg.getValue(); \
      xmlSwitch = xmlSwitchArg.getValue(); \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      returnParameterFile = returnParameterFileArg.getValue(); \

#define GENERATE_TCLAP GENERATE_TCLAP_PARSE;GENERATE_TCLAP_ASSIGNMENT
#define GENERATE_TCLAP_ASSIGNMENT_IFSET \
    if( InputLabel_AArg.isSet() ) \
      { \
      InputLabel_A = InputLabel_AArg.getValue(); \
      } \
    if( InputFibersArg.isSet() ) \
      { \
      InputFibers = InputFibersArg.getValue(); \
      } \
    if( OutputKeptFibersArg.isSet() ) \
      { \
      OutputKeptFibers = OutputKeptFibersArg.getValue(); \
      } \
    if( OutputRemovedFibersArg.isSet() ) \
      { \
      OutputRemovedFibers = OutputRemovedFibersArg.getValue(); \
      } \
    if( MinimumNumberOfPointsArg.isSet() ) \
      { \
      MinimumNumberOfPoints = MinimumNumberOfPointsArg.getValue(); \
      } \
    if( KernelSizeArg.isSet() ) \
      { \
      KernelSize = KernelSizeArg.getValue(); \
      } \
    if( PercentInsideMaskArg.isSet() ) \
      { \
      PercentInsideMask = PercentInsideMaskArg.getValue(); \
      } \
    if( VerboseArg.isSet() ) \
      { \
      Verbose = VerboseArg.getValue(); \
      } \
    if( parametersSerializeArg.isSet() ) \
      { \
      parametersSerialize = parametersSerializeArg.getValue(); \
      } \
    if( parametersDeSerializeArg.isSet() ) \
      { \
      parametersDeSerialize = parametersDeSerializeArg.getValue(); \
      } \
    if( echoSwitchArg.isSet() ) \
      { \
      echoSwitch = echoSwitchArg.getValue(); \
      } \
    if( xmlSwitchArg.isSet() ) \
      { \
      xmlSwitch = xmlSwitchArg.getValue(); \
      } \
    if( processInformationAddressStringArg.isSet() ) \
      { \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      } \
    if( returnParameterFileArg.isSet() ) \
      { \
      returnParameterFile = returnParameterFileArg.getValue(); \
      } \

#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    InputLabel_A: " << InputLabel_A << std::endl; \
std::cout << "    InputFibers: " << InputFibers << std::endl; \
std::cout << "    OutputKeptFibers: " << OutputKeptFibers << std::endl; \
std::cout << "    OutputRemovedFibers: " << OutputRemovedFibers << std::endl; \
std::cout << "    MinimumNumberOfPoints: " << MinimumNumberOfPoints << std::endl; \
std::cout << "    KernelSize: " << KernelSize << std::endl; \
std::cout << "    PercentInsideMask: " << PercentInsideMask << std::endl; \
std::cout << "    Verbose: " << Verbose << std::endl; \
std::cout << "    parametersSerialize: " << parametersSerialize << std::endl; \
std::cout << "    parametersDeSerialize: " << parametersDeSerialize << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_DECLARE;GENERATE_DESERIALIZATION;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;GENERATE_SERIALIZATION;
